---
title: "BGG Game Profiles"
author: "Phil Henrickson"
date: "`r Sys.Date()`"
output: 
  html_document:
        toc: true
        toc_depth: 3
params:
  id: 54998
---

```{r global settings, echo=F, warning=F, message=F, results = 'hide'}

knitr::opts_chunk$set(echo = F,
                      error=F,
                      dev="png",
                      fig.width = 9,
                      fig.height = 6)

options(knitr.duplicate.label = "allow")

options(scipen=999)

source(here::here("scripts/load_packages.R"))
source(here::here("functions/theme_phil.R"))
library(plumber)
rm(a)

```

```{r flextable settings, results = 'hide', echo=F, warning=F, message=F}

#library(webshot2)
library(flextable)
library(kableExtra)
library(cowplot)
library(magick)
library(gt)

set_flextable_defaults(theme_fun = theme_alafoli,
                       font.color = "black",
  padding.bottom = 6, 
  padding.top = 6,
  padding.left = 6,
  padding.right = 6,
  background.color = "white")

```

```{r load functions, warning=F, message=F, results = 'hide'}

# function for loading game by id
source(here::here("functions/get_game_comparables.R"))

# function for loading game record
source(here::here("functions/get_game_record.R"))

# rename func
source(here::here("functions/rename_func.R"))

# predict
source(here::here("functions/bake_and_predict_avgweight_and_ratings.R"))

# function for renaming and tidying output
source(here::here("functions/rename_func.R"))
source(here::here("functions/baverage_func.R"))
source(here::here("functions/average_func.R"))
source(here::here("functions/avgweight_func.R"))

# # get record
# suppressMessages({
#         record = get_game_record(params$id)
# })

suppressMessages({
record = get_game_record(params$id) %>%
        mutate(number_designers = rowSums(across(starts_with("des_"))))
})

```

## What is this analysis?

This notebook is for selecting any boardgame and identifying **its most comparable games using data from boardgamegeek.com**. I use a dimension reduction method (PCA) to learn the main points of variation in data about games from boardgamegeek. To find similar games, I compute the distance between all games using their first twenty principal components. I use the distance between games to determine their overall similarity. Games that are close to each other are said to be *neighbors*.

This document details a game's 25 nearest neighbors and illustrate some of the dimensions that make the selected game and its neighbors similar.

## Game Profile: **`r paste(record$name[1])`**

```{r predict rating and weight, warning=F, message=F, results = 'hide'}

# predict weight and complexity
game_preds = bake_and_predict_avgweight_and_ratings(params$id,
                                                    "xgbTree_fit")

estimated_values = bind_rows(game_preds$estimated_weight,
                             game_preds$estimated_rating) %>%
        mutate(method = gsub("_fit", "", method)) %>%
        select(game_id, name, yearpublished, outcome, pred) %>%
        spread(outcome, pred) %>%
        mutate(game_id = as.character(game_id),
               yearpublished = as.character(yearpublished)) %>%
        rename(ID = game_id,
               Game = name,
               Published = yearpublished,
               Average = average,
               Geek = baverage,
               Complexity = avgweight) %>%
        mutate(Type = "Estimated") %>%
        select(Type, Average, Geek, Complexity)

game_info = record %>%
      #  select(game_id, yearpublished, name) %>%
        rename(ID = game_id,
               Published = yearpublished,
               Average = average,
               UserRatings = usersrated,
               Geek= baverage,
               Complexity = avgweight,
               Game = name) %>%
        mutate(`Player Count` = paste(minplayers, maxplayers, sep="-"),
         `Playing Time` = paste(as.character(playingtime), " min", sep="")) %>%
        mutate_if(is.numeric, replace_na, 0) %>%
        # left_join(.,
        #           estimated_values %>%
        #                   rename(`Average ` = average,
        #                          `Geek ` = baverage,
        #                          `Complexity ` = avgweight),
        #           by = c("ID" = "game_id")) %>%
        mutate_if(is.numeric, round, 2) %>%
       # mutate_if(is.numeric, as.character) %>%
        mutate(Published = as.character(Published),
               ID = as.character(ID)) %>%
        mutate(Type = "Current") %>%
        mutate(Date = Sys.Date()) %>%
        select(ID, Game, Published, `Player Count`, `Playing Time`, UserRatings, Type, Average, Geek, Complexity) %>%
        bind_rows(., 
                  estimated_values)

```

First, we can look at summary information for the game as it currently stands on BGG. For the average rating (Average), geek rating (Geek), and average weight (Complexity) of a game, I estimate the game's values using predictive models trained on historical BGG data.

```{r table of game info, fig.height=1.5, fig.width=10}

game_info %>%
        flextable() %>%
        flextable::autofit() %>%
        bold(part = "header") %>%
        bg(., j = c("Geek"),
           bg = baverage_func) %>%
        bg(., j = c("Average"),
           bg = average_func) %>%
        bg(., j="Complexity",
           bg = avgweight_func) %>%
        add_header_row(values = c("",
                               "",
                               "",
                               "",
                               "",
                               "",
                               "",
                               "Outcomes", 
                               "Outcomes",
                               "Outcomes")) %>%
        merge_h(part = "header") %>%
        flextable::align(j = c("Average",
                               "Geek",
                               "Complexity"),
                         align = "center",
                         part = "all")

#%>%
  #set_caption(paste("Game Profile for ", record$name[1], ". Data from boardgamegeek.com", sep=""))

# game_info$Game = str_wrap(game_info$Game, 40)
#   #       flextable() %>%
#   #    #   flextable::autofit() %>% 
#   #       bold(part = "all") %>%
#   # as_raster()

# t_game_info = tableGrob(game_info %>%
#                           rename_all(toupper),
#                         theme=ttheme_game, rows=NULL)

# grid.arrange(t_game_info,
#              ncol =1)

# game_info %>%
#   flextable() %>%
#   flextable::align(align = "center", part = "all") %>%
#   flextable::autofit() %>%
#   bold(part = "all")

             
```

Information on the game's designers, artists, mechanics and categories. Note: designer and artist features are not used in identifying nearest neighbors.

```{r show game mechanics}

publishers = record %>%
        select(starts_with("pub_")) %>%
        names() %>%
        rename_func() %>%
        as_tibble()

designers = record %>%
        select(starts_with("des_")) %>%
        names() %>%
        rename_func() %>%
        as_tibble()

artists = record %>%
        select(starts_with("art_")) %>%
        names() %>%
        rename_func() %>%
        gsub("Art ", "", .) %>%
        as_tibble()

mechanics = record %>%
        select(starts_with("mech_")) %>%
        names() %>%
        rename_func() %>%
        as_tibble()

categories = record %>%
        select(starts_with("cat_")) %>%
        names() %>%
        rename_func() %>%
        as_tibble()

# get maximum length
max = max(c(nrow(publishers),
            nrow(designers),
            nrow(mechanics),
            nrow(artists),
            nrow(categories)))

# info ft
info = record %>%
        select(game_id,
               name,
               yearpublished) %>%
        mutate_at(c("game_id", "yearpublished"),
                                   ~ as.character(.))

info_ft = info %>%
        bind_rows(., 
        rep(NA, times = max - nrow(info)+1) %>%
                as_tibble) %>%
        select(game_id, name, yearpublished)
                  

publisher_ft = publishers %>%
        bind_rows(., 
                  rep(NA, times =  max - nrow(publishers)+1) %>%
                          as_tibble()) 

designer_ft = designers %>%
        bind_rows(., 
                  rep(NA, times =  max - nrow(designers)+1) %>%
                          as_tibble()) 

artist_ft = artists %>%
        bind_rows(., 
                  rep(NA, times =  max - nrow(artists)+1) %>%
                          as_tibble()) 
        
mech_ft = mechanics %>%
        bind_rows(., 
                  rep(NA, times =  max - nrow(mechanics)+1) %>%
                          as_tibble())

cat_ft = categories %>%
        bind_rows(., 
                  rep(NA, times =  max - nrow(categories)+1) %>%
                          as_tibble())
# combine to flextable
cbind.data.frame(
        info_ft,
        publisher_ft,
        designer_ft,
         artist_ft,
         cat_ft,
         mech_ft) %>%
        set_names(., c("ID",
                       "Game",
                       "Published",
                       "Publisher(s)", 
                       "Designer(s)",
                       "Artist(s)", 
                       "Categories", 
                       "Mechanics")) %>%
        flextable() %>%
        flextable::autofit() %>%
        bold(part = "header")

```

For the full profile of the selected game, go to `r paste("https://boardgamegeek.com/boardgame/", params$id, sep="")`

## Most Similar Games to **`r paste(record$name[1])`**

The table below displays the most similar games to `r paste(record$name[1])` using data from boardgamegeek (BGG). The reported similarity score is the (squared) inverse of the Manhattan distance between two games. 

**Note:** The analysis does not make use of a game's number of ratings, average, or geek average, but instead looks only at a game's categories, mechanics, playing time, player count, and complexity. The current approach for computing the distance weighs each component equally; I plan to explore a change to this in the future by using different measures of distance, as we would reasonably expect some components to be more important than others. I initially relied on Euclidean distance, but in tinkering with the results I have opted to go with the Manhattan distance for now.


```{r run comps analysis, message=F, warning=F, results = 'hide'}

id = params$id

# load active files
unsupervised_obj = 
        readr::read_rds(here::here("active", "unsupervised_obj.Rdata"))

unsupervised_neighbors = 
        readr::read_rds(here::here("active", "unsupervised_neighbors.Rdata")) 

recipe_prep = 
        readr::read_rds(here::here("active", "unsupervised_recipe_prep.Rdata"))

games_flattened = 
        readr::read_rds(here::here("active", "games_flattened.Rdata"))  %>%
        select(game_id,
               name,
               yearpublished,
               average,
               baverage,
               avgweight,
               playingtime,
               usersrated,
               minplayers,
               maxplayers)

# check to see if id is in the unsupervised object
check_obs = unsupervised_obj %>%
        filter(dataset == 'fundamentals, mechanics, and categories') %>%
        select(dataset, pca_with_data) %>%
        unnest(c(dataset, pca_with_data)) %>%
        filter(game_id == id) %>%
        nrow()

# get table of games
active_games = unsupervised_obj %>% 
        filter(dataset == 'fundamentals, mechanics, and categories') %>%
        select(pca_with_data) %>% unnest() %>%
        arrange(desc(baverage)) %>%
        mutate(rank = row_number())

### if game record is in our previously run analysis, we can just look it up
if(check_obs > 0) {
        
        # get game name
        game = unsupervised_neighbors %>%
                filter(game_id == id) %>%
                pull(name) %>%
                unique()
        
        neighbors_table = unsupervised_neighbors %>%
                filter(game_id == id) %>%
                #    filter(dataset == 'fundamentals, mechanics, and categories') %>%
                select(dataset, game_id, name, neighbor_game_id, neighbor_name, similarity, dist, perc, yearpublished, rank, average, baverage, avgweight) %>%
                filter(yearpublished < 2022) %>%
                mutate(game_id = as.character(game_id),
                       neighbor_game_id = as.character(neighbor_game_id),
                       yearpublished = as.character(yearpublished)) %>%
                rename(BGGRank = rank,
                       BGGRating = average,
                       GeekRating = baverage) %>%
                group_by(dataset) %>%
                arrange(dataset, dist) %>%
                mutate(rank = row_number()) %>%
                ungroup() %>%
                filter(rank <=25) %>%
                rename(Comparing_By = dataset,
                       Similarity = similarity,
                       ID = neighbor_game_id,
                       Complexity = avgweight,
                       Game = name,
                       Published = yearpublished,
                       Neighbor = neighbor_name,
                       Rank = rank) %>%
                select(Comparing_By, Similarity, Rank, ID, Published, Neighbor, BGGRating, GeekRating, Complexity) %>%
                mutate_if(is.numeric, round, 2)
        
} else {
        
        print("game not in existing dataset; pulling game info from BGG and calculating...")
        
        # use preivously grabbed record with estimated complexity
        game_record = record
        game_record$avgweight = game_preds$estimated_weight$pred
                
        # get the name
        game = game_record %>%
                pull(name)
        
        # nest for placemen
        # bak
        baked_game = recipe_prep %>%
                prep(recipe_prep$template, strings_as_factor = F) %>%
                bake(new_data = bind_rows(game_record, recipe_prep$template[0,]))
        
        # nest
        nested_game_data<- baked_game %>%
                mutate(dataset = "fundamentals, mechanics, and categories") %>%
                nest(-dataset) %>%
                bind_rows(., baked_game %>%
                                  mutate(dataset = "fundamentals and mechanics") %>%
                                  select(-starts_with("cat_"),
                                         -number_categories) %>%
                                  nest(-dataset))
        
        ### get comparables for game
        comps_obj = unsupervised_obj %>%
                select(dataset, pca_trained) %>% # get pca
                left_join(., nested_game_data,
                          by = "dataset") %>%
                mutate(pca_rotation = map2(.x = pca_trained,
                                           .y = data,
                                           ~ .x %>% bake(new_data = .y))) %>%
                mutate(pca_with_data = map2(.x = pca_rotation,
                                            .y = data,
                                            ~ .x %>%
                                                    select(game_id, starts_with("PC")) %>%
                                                    left_join(., .y,
                                                              by = "game_id"))) %>%
                mutate(type = "game") %>%
                select(dataset, pca_with_data, type) %>%
                bind_rows(., unsupervised_obj %>%
                                  select(dataset, pca_with_data) %>%
                                  unnest() %>%
                                  filter(game_id != id) %>%
                                  nest(-dataset, -type) %>%
                                  rename(pca_with_data = data)) %>%
                mutate(pca_with_data = map(pca_with_data, ~.x %>%
                                                   rename_all(funs(gsub("PC0", "PC", gsub("PC00", "PC", make.names(names(.x)))))))) %>%
                unnest() %>%
                nest(-dataset) %>%
                rename(pca_with_data = data)
        
        # now combine
        unsupervised_obj = comps_obj %>%
                left_join(., 
                          unsupervised_obj %>%
                                  select(dataset, kmeans, norm_trained, pca_trained),
                          by = "dataset") %>%
                mutate(pca_dist = map(.x = pca_with_data, 
                                      ~ dist(.x %>%
                                                     select(PC1:PC10) %>%
                                                     as.matrix(), 
                                             method="euclidean") %>%
                                              as.matrix() %>%
                                              as.data.frame() %>%
                                              magrittr::set_rownames(.x$game_id) %>%
                                              magrittr::set_colnames(.x$game_id))) %>%
                mutate(obs_dist = map(pca_dist, ~ .x %>%
                                              rownames_to_column("game_id") %>%
                                              filter(game_id == id) %>%
                                              gather('closest','dist',-game_id) %>%
                                              filter(dist > 0) %>%
                                              filter(!is.na(dist)) %>% 
                                              group_by(game_id) %>% 
                                              arrange(dist) %>% 
                                              slice_min(dist, n=50, with_ties = T) %>%
                                              mutate(dist_rank=row_number()))) %>%
                mutate(neighbors = map(obs_dist,
                                       ~ left_join(.x, game_record %>%
                                                           mutate(game_id = as.character(game_id)),
                                                   by = c("game_id")) %>%
                                               select(game_id, name, closest, dist, dist_rank) %>% 
                                               left_join(., active_games %>%
                                                                 mutate(game_id = as.character(game_id)) %>%
                                                                 rename(neighbor_game_id = game_id,
                                                                        neighbor_name = name),
                                                         by = c("closest" = "neighbor_game_id")))) %>%
                mutate(scale_data = map2(.x = norm_trained,
                                         .y = pca_with_data,
                                         ~ .x %>% bake(new_data = .y %>%
                                                               select(-starts_with("PC")) %>%
                                                               filter(game_id == id)) %>%
                                                 select(-timestamp,
                                                        -game_id,
                                                        -name,
                                                        -average,
                                                        -baverage,
                                                        -usersrated,
                                                        -yearpublished))) %>%
                mutate(clusters = map2(.x = kmeans,
                                       .y = scale_data,
                                       ~ clue::cl_predict(.x, 
                                                          newdata = .y)))
        
        # extract neighbors and report
        neighbors_table= unsupervised_obj %>%
                select(dataset, neighbors) %>% 
                unnest() %>%
                rename(neighbor = neighbor_name,
                       neighbor_id = closest) %>%
                mutate(similarity = 100*1/(1+ sqrt(dist))) %>%
                select(dataset, game_id, name, neighbor, neighbor_id, similarity, dist, dist_rank) %>%
                left_join(., active_games %>%
                                  mutate(game_id = as.character(game_id)) %>%
                                  rename(neighbor_id = game_id,
                                         neighbor = name),
                          by = c("neighbor_id", "neighbor")) %>%
                rename(BGGRank = rank,
                       BGGRating = average,
                       GeekRating = baverage)  %>%
                filter(yearpublished < 2022) %>% # set years allowed for nearest neighbors
                group_by(dataset) %>%
                mutate(rank = row_number()) %>%
                filter(rank <=25) %>%
                ungroup() %>%
                mutate_if(is.numeric, round, 2) %>%
                #  select(-game_id, -similarity, -dist, -dist_rank) %>%
                mutate(yearpublished = as.character(yearpublished),
                       neighbor_id = as.character(neighbor_id)) %>%
                rename(Comparing_By = dataset,
                       Similarity = similarity,
                       ID = neighbor_id,
                       Complexity = avgweight,
                       Game = name,
                       Published = yearpublished,
                       Neighbor = neighbor,
                       Rank = rank) %>%
                select(Comparing_By, Similarity, Rank, ID, Published, Neighbor, BGGRating, GeekRating, Complexity) %>%
                mutate_if(is.numeric, round, 2)
        
}


```


<!-- ```{r comps and get for game, warning=F, message=F, results = 'hide'} -->

<!-- comps = get_game_comparables(params$id) -->

<!-- ``` -->

```{r examine table}

# ready for flextable
neighbors_table %>%
        select(Rank, Similarity, Published, ID, Neighbor, BGGRating, GeekRating, Complexity) %>%
        filter(Rank <=25) %>%
        flextable() %>%
        flextable::autofit() %>%
        #   add_footer(paste("Most similar games to", game, "using complexity, playing time, player count, mechanics, and categories", sep=" ")) %>%
        # bg(., i = ~ Comparing_By =='fundamentals, mechanics, and categories',
        #    bg = 'grey100') %>%
        # bg(., i = ~ Comparing_By == 'fundamentals and mechanics',
        #    bg = 'grey90') %>%
        bg(., j = c("GeekRating"),
           bg = baverage_func) %>%
        bg(., j = c("BGGRating"),
           bg = average_func) %>%
        bg(., j = c("Complexity"),
           bg = avgweight_func)
        
```

## Plotting Comparable Games to **`r paste(record$name[1])`**

Placing the selected game and its nearest neighbors on the first two principal components.

```{r compute buch of elements for plotting, warning=F, message=F, results = 'hide'}

# now make plot
# make visualization to compare observations on the principal components
df = unsupervised_obj[1,]$pca_with_data[[1]] %>%
        select(game_id, name, PC1:PC20)

# selected principal components
profile_df = df %>%
        melt(., id.vars = c("game_id", "name")) %>%
        group_by(variable) %>%
        mutate(scale = scale(value, center=T, scale=T)) %>%
        ungroup()

# make plot
# make a plot
plot_df = df %>%
        melt(., id.vars = c("game_id", "name")) %>%
        mutate(variable = case_when(variable == 'PC1' ~ 'PC1_Complexity',
                                    variable == 'PC2' ~ 'PC2_Storytelling',
                                    variable == 'PC3' ~ 'PC3_Economy',
                                    variable == 'PC4' ~ 'PC4_Cooperation')) %>%
      #                              variable == 'PC5' ~ 'PC5_Trains')) %>%
        filter(!is.na(variable)) %>%
        group_by(variable) %>%
        mutate(scale = scale(value, center=T, scale=T))

# jitter
library(ggforce)
set.seed(2)
pos <- position_jitternormal(sd_x = 0.075, sd_y = 0.025)
pos2 <- position_jitternormal(sd_x = 0.025, sd_y = 0.025)

# make background plot
set.seed(2)
background = plot_df %>%
        ggplot(., aes(x=variable,
                      y = value))+
        geom_jitter(alpha=0.1,
                    col = 'grey60',
                    position = pos)+
        theme_phil()+
        geom_hline(yintercept = 0,
                   linetype = 'dashed',
                   alpha = 0.8)+
        theme(legend.position = 'top',
              legend.title = element_blank())+
        theme(panel.grid.major = element_blank(),
              panel.grid.minor = element_blank())+
        ggtitle(paste("Which games are similar to ", game, "?", sep= ""),
                subtitle = str_wrap("Placing games on first four principal components of variation, which generally correspond complexity, theme, economy, and coooperation.", 125))+
        theme(panel.grid.major = element_blank(),
              panel.grid.minor = element_blank())+
        geom_vline(xintercept = 0,
                   color = 'grey60',
                   linetype = 'dashed')+
        geom_hline(yintercept = 0,
                   color = 'grey60',
                   linetype = 'dashed')

# closest IDs
compare = c(neighbors_table %>%
                    filter(Rank <=6) %>%
                    pull(ID))

# all neighbor IDs
compare_full = c(neighbors_table %>%
                         pull(ID))
# all neighbors
neighbors = c(game, neighbors_table %>%
                      group_by(Neighbor) %>%
                      mutate(dupe = n()) %>%
                      mutate(Neighbor = case_when(Neighbor == game ~ 
                                                          paste(Neighbor, 
                                                                ID,
                                                                sep =" "),
                                                  dupe > 1 ~ 
                                                          paste(Neighbor, 
                                                                ID,
                                                                   sep=" "),
                                                  TRUE ~ Neighbor)) %>%
                      ungroup() %>%
                      pull(Neighbor)) %>%
        rev()

# set levels for all
df_closest_neighbors = df %>%
        filter(game_id %in% c(id, compare)) %>%
        mutate(name = factor(name, levels = rev(neighbors)[1:7]))

```


```{r examine pc plot, fig.height=8, fig.width=10, warning=F, message=F}

# plot backgrond for pc1 and pc2
pc_plot_background = df %>%
                ggplot(., aes(x=PC1,
                              label = name,
                              y = PC2))+
                geom_point(alpha = 0.15,
                           col = "grey60")+
                geom_text(check_overlap=T,
                          vjust = 0.5,
                          col = "grey80",
                          size =2)+
                theme_phil()+
                theme(panel.grid.major = element_blank(),
              panel.grid.minor = element_blank())+
        geom_vline(xintercept = 0,
                   color = 'grey60',
                   linetype = 'dashed')+
        geom_hline(yintercept = 0,
                   color = 'grey60',
                   linetype = 'dashed')
                  

# pc 1 and 2 plot
pc_plot = pc_plot_background +
                geom_point(data = df_closest_neighbors,
                           aes(x=PC1,
                               label = name,
                               color = name,
                               y=PC2),
                           size = 3)+
                geom_label_repel(data = df_closest_neighbors,
                           aes(x=PC1,
                               label = name,
                               color = name,
                               y=PC2),
                           size =3,
                           max.overlaps = 12)+
                guides(label = "none",
                       color = "none",
                       size = "none")+
                scale_color_viridis_d(option = "magma",
                                      begin = 0,
                                      end = 0.8)+
                theme(panel.grid.major = element_blank(),
                      panel.grid.minor = element_blank())

pc_plot+
  theme(panel.grid.minor = element_blank(),
        panel.grid.major = element_blank())+
  ylab("PC2_Thematic")+
  xlab("PC1_Complexity")+
  annotate("label",
           x=-4.5,
           y=10,
          label = "Party/Deduction")+
    annotate("label",
           x=7,
           y=10,
          label=  "Thematic")+
  annotate("label",
           x =-5,
           y = -3,
         label =  "Family/Abstract")+
    annotate("label",
           x =2.5,
           y = -5.5,
         label =  "Euros/Trains")+
  annotate("label",
           x=11,
           y = -3,
        label = "Simulation/Wargame")+
  ggtitle(paste("What type of game is ", record$name, "?", sep=""),
          subtitle = str_wrap("Mapping all games on BGG by first two principal components of variation (complexity and storytelling), which identifies specific clusters of game types. The selected game and its nearest neighbors are highlighted to identify where they are placed in this mapping of games.", 125))

```

$$\\[0.05in]$$

Placing games on the first four principal components, which I have found to loosely map to complexity, theme, economy, and cooperation.

```{r examine nplot, fig.height=8, fig.width=10, warning=F, message=F}

arrow_style <- arrow(length = unit(.05, "inches"),
                     type = "closed")

# reference ids
plot_df_references = 
        bind_rows(
                plot_df %>%
                        group_by(variable) %>% 
                        slice_max(., order_by = value, n=2),
                plot_df %>%
                        group_by(variable) %>% 
                        slice_min(., order_by = value, n=2))

# selected game and its neighbors
plot_df_neighbors = plot_df %>%
        filter(game_id %in% c(id, compare)) %>%
        mutate(name = factor(name, levels = rev(neighbors)[1:7]))

set.seed(2)
background + 
        geom_segment(alpha=0.2,
                     aes(xend = 1, yend = -10), 
                     x = 1, y = -6, 
                     color = 'grey60',
                     alpha = 0.2,
               arrow = arrow_style)+
        geom_segment(alpha=0.2,
                     aes(xend = 1, yend = 14), 
                     x = 1, y = 10,
                     color = 'grey60',
               arrow = arrow_style)+
        geom_segment(alpha=0.2,
                     aes(xend = 2, yend = -10), 
                     x = 2, y = -5, 
                     color = 'grey60',
                     alpha = 0.2,
               arrow = arrow_style)+
        geom_segment(alpha=0.2,
                     aes(xend = 2, yend = 15), 
                     x = 2, y = 11,
                     color = 'grey60',
               arrow = arrow_style)+
        geom_segment(alpha=0.2,
                     aes(xend = 3, yend = -11), 
                     x = 3, y = -6, 
                     color = 'grey60',
                     alpha = 0.2,
               arrow = arrow_style)+
        geom_segment(alpha=0.2,
                     aes(xend = 3, yend = 14), 
                     x = 3, y = 10,
                     color = 'grey60',
               arrow = arrow_style)+
        geom_segment(alpha=0.2,
                     aes(xend = 4, yend = -12), 
                     x = 4, y = -6, 
                     color = 'grey60',
                     alpha = 0.2,
               arrow = arrow_style)+
        geom_segment(alpha=0.2,
                     aes(xend = 4, yend = 14), 
                     x = 4, y = 10,
                     color = 'grey60',
               arrow = arrow_style)+
        geom_point(data = plot_df_references, 
                         aes(x = variable,
                             y=value,
                             label = name),
                         position = pos2,
                   alpha=0.3)+
        geom_text_repel(data = plot_df_references, 
                         aes(x = variable,
                             y=value,
                             label = name),
                         position = pos2,
                         show.legend=F,
                         alpha=0.4,
                         size = 2)+
        # geom_jitter(data = plot_df %>%
        #                           filter(game_id %in% id),
        #                   aes(x = variable,
        #                       size = highlight,
        #                       y = scale),
        #             color = "black",
        #             size = 2.5,
        #             position = pos2)+
        geom_point(data = plot_df_neighbors,
                    aes(x = variable,
                        color = name,
                        y = value),
                    size = 2,
                    position = pos2)+
        geom_label_repel(data = plot_df_neighbors,         
                         aes(x = variable,
                             color = name,
                             y=value,
                             label = name),
                         position = pos2,
                         max.overlaps=14,
                         show.legend=F,
                         size = 2.5)+
        guides(label = "none",
               color = "none",
               size = "none")+
     #   scale_color_colorblind()+
        scale_color_viridis_d(option="magma",
                              begin = 0,
                              end = 0.8)+
        annotate("text",
                           fontface = 2,
                         x= 1,
                         y=c(-11, 15),
                         label = c("Simple/Short", "Complex/Lengthy"))+
        annotate("text",
                             fontface = 2,
                         x= 2,
                         y=c(-13, 15.5),
                         label = c("Abstract", "Thematic/Storytelling"))+
        annotate("text",
                               fontface =2,
                         x= 3,
                         y=c(-12, 15),
                         label = c("Conflict/Wargame", "Economic"))+
        annotate("text",
                               fontface = 2,
                         x= 4,
                         y=c(-14, 15),
                         label = c("Social/Deception", "Adventure/Cooperation"))+
                         #      annotate("text",
                         #       fontface = 2,
                         # x= 5,
                         # y=c(-14, 12),
                         # label = c("Cards", "Trains/Networks"))+
        xlab("")+
        ylab("Value")

```

$$\\[0.05in]$$

## Comparing Games on Principal Components

The chart below shows how `r paste(record$name[1])` compares to its nearest neighbors on each of the twenty principal components. Similar games will have similar profiles in terms of their placement on each dimension. This can be a useful way to easily see the dimensions on which games resemble each other. I've also plotted games that are at the tails of each component to get a reference point.

```{r line plot, fig.height=8, fig.width=12, warning=F, message=F}

# reference ids
profile_df_references = 
        bind_rows(
                profile_df %>%
                        group_by(variable) %>% 
                        slice_max(., order_by = value, n=2),
                profile_df %>%
                        group_by(variable) %>% 
                        slice_min(., order_by = value, n=2)) %>%
                filter(variable %in% paste("PC", seq(1,20), sep = ""))

line_plot = profile_df %>%
        filter(variable %in% paste("PC", seq(1,20), sep = "")) %>%
        filter(game_id %in% c(id, compare_full)) %>%
        #     mutate(name = paste(name, game_id, sep="_")) %>%
        mutate(name = factor(abbreviate(name,
                                        minlength=20),
                             levels = abbreviate(rev(neighbors),
                                                 minlength=20))) %>%
        filter(game_id %in% c(id, compare)) %>%
        # mutate(name = factor(abbreviate(name,
        #                                 minlength=30), 
        #                      levels = rev(abbreviate(neighbors[1:7],
        #                                   minlength=30)))) %>%
        ggplot(., aes(x=variable,
                      y=value,
                      color = name,
                      group = name))+
        geom_hline(yintercept = 0,
                   linetype = 'dashed',
                   color = 'grey60')+
        geom_line(lwd=1.01)+
        geom_point()+
        theme_phil()+
        coord_cartesian(ylim = c(-15, 15))+
    #    theme(legend.title = element_text())+
     #   scale_color_colorblind()+
        theme(legend.position = "right")+
        xlab("")+
        ylab("Component Score")+
        theme(panel.grid.minor = element_blank())+
        scale_color_viridis_d(option = "magma",
                                      begin = 0,
                                      end = 0.8)+
        # scale_fill_viridis(option="magma",
        #                    limits = c(-5,5),
        #                    oob = scales::squish)+
        ggtitle(paste("How are games similar to ", record$name[1], "?", sep=""),
            subtitle = str_wrap("Plotting selected games and its neighbors on each of the twenty principal components. Similar games will have a similar path along each of the components.", 125))

line_plot +
        geom_point(data = profile_df_references,
                         aes(x = variable,
                             y=value),
                   color = 'grey40',
                   show.legend = F,
                   alpha=0.4)+
        geom_text_repel(data = profile_df_references, 
                         aes(x = variable,
                             y=value,
                             label = abbreviate(name,
                                                minlength=50)),
                         color = 'grey40',
                         show.legend=F,
                         alpha=0.4,
                         size = 2)+
        theme(panel.grid.major.y = element_blank())

        
```

We can also use a tile plot to view each of the neighbors across every principal component used, which can be a useful way of looking to see if there's one dimension in particular on which the games stand out.

```{r tile plot, fig.height=8, fig.width=10, warning=F, message=F}

profile_df %>%
        filter(game_id %in% c(id, compare_full)) %>%
        mutate(name_id = paste(name, game_id, sep=" ")) %>%
        mutate(dupe = case_when(name_id %in% neighbors ~ 1,
               TRUE ~ 0)) %>%
        mutate(name = case_when(dupe ==1 ~ name_id,
                                TRUE ~ name)) %>%
        #     mutate(name = paste(name, game_id, sep="_")) %>%
        mutate(name = factor(abbreviate(name,
                                        minlength=30),
                             levels = abbreviate(neighbors,
                                                 minlength=30))) %>%
    #    mutate(scale_round = round(scale, 2)) %>%
        ggplot(., aes(x=variable,
                      y=name,
                      fill = value))+
        geom_tile(color = 'white',
                  color = 'grey50')+
        geom_text(aes(label = round(value, 2)),
                  size = 2.5)+
        theme_phil()+
        theme(legend.title = element_text())+
        guides(color = "none",
               fill = guide_colorbar(barheight=0.5,
                                     barwidth=10,
                                     title = "Low                     High",
                                     #  title = "              Z Score",
                                     title.position = "top"))+
        theme(legend.position = "top")+
        xlab("")+
        ylab("")+
        theme(panel.grid.minor = element_blank(),
              panel.grid.major = element_blank())+
        scale_fill_gradient2(low = "red",
                             mid = "white",
                             high = "blue",
                             limits = c(-5, 5),
                             oob = scales::squish)+
        ggtitle(paste("How are games similar to ", record$name[1], "?", sep=""),
            subtitle = str_wrap("Placing selected game and its neighbors on each of the ten principal components. Similar games will have similar profiles across each of the components.", 125))

```

## Examining PCA Variable Loadings

What explains a game's score on each principal component?

To gain a better understanding of these principal components, we can look at the loadings for the variables in the dataset. These are the the contributions of each variable to the ten components used in computing the distance between games. Large loadings (either positive or negative) for a variable indicate that there is a strong relationship between that variable and the component.

For instance, on the first principal component (PC1), **time per player**, **average weight**, and **playing time** have the highest positive loadings, while **party game** and **max players** have negative loadings. This indicates that this component seems to map to a game's complexity - longer, more complex games will have high positive scores on this component while simpler, shorter, party games with lots of players will have low scores. 

```{r examine variable loadings, warning=F, message=F, fig.height=20, fig.width=10}

unsupervised_neighbor_components = 
        readr::read_rds(here::here("active", "unsupervised_obj_components.Rdata")) 

source(here::here("functions/rename_func.R"))

unsupervised_neighbor_components %>%
        filter(component %in% paste("PC", seq(1,20), sep="")) %>%
        mutate(component = factor(component,
                                 levels = paste("PC", seq(1,20), sep=""))) %>%
  group_by(dataset, component) %>%
  slice_max(., order_by = abs(value),
            n = 15) %>%
  mutate(terms = rename_func(terms)) %>%
  ggplot(., aes(x=value,
                fill = value,
                y = reorder_within(terms, by =value, within = component)))+
  geom_col()+
  scale_y_reordered()+
  facet_wrap(. ~ component,
             ncol =2,
             scales = "free_y")+
  theme_phil()+
  ylab("feature")+
  xlab("contribution")+
  guides(fill = guide_colorbar(barwidth = 10,
                               barheight=0.5))+
        scale_fill_gradient2(low = "red",
                             mid = "white",
                             high = "blue",
                            # limits = c(-5, 5),
                             oob = scales::squish)+
  ggtitle("What contributes to each principal component?")+
  guides(fill = "none")
        
```
